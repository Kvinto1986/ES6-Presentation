{\rtf1\ansi\ansicpg1251\cocoartf1671\cocoasubrtf100
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fswiss\fcharset0 ArialMT;\f2\fnil\fcharset0 HelveticaNeue-Bold;
\f3\fnil\fcharset0 Menlo-Regular;\f4\fnil\fcharset0 HelveticaNeue;\f5\fnil\fcharset0 HelveticaNeue-Italic;
}
{\colortbl;\red255\green255\blue255;\red25\green25\blue25;\red255\green255\blue255;\red27\green31\blue34;
\red21\green23\blue26;\red26\green26\blue26;\red51\green51\blue51;\red254\green254\blue254;}
{\*\expandedcolortbl;;\cssrgb\c12941\c12941\c12941;\cssrgb\c100000\c100000\c100000;\cssrgb\c14118\c16078\c18039;
\cssrgb\c10588\c12157\c13725\c4706;\cssrgb\c13333\c13333\c13333;\cssrgb\c25882\c25882\c25882;\cssrgb\c99608\c99608\c99608;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\paperw11900\paperh16840\margl1440\margr1440\vieww37900\viewh19880\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\qc\partightenfactor0

\f0\fs24 \cf0  
\f1\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
//slide1\
\pard\pardeftab720\sl360\qc\partightenfactor0
\cf2 Hello everyone, my name is Yan, and today I would like to talk about such an important topic for newbies in programming as ECMAScript standard.\
\
//slide2\
ECMAScript 2015, also known as ES6, is a fundamental version of the ECMAScript standard.\
Since this long time passed between ES5.1 and ES6, the release is full of important new features and major changes in suggested best practices in developing JavaScript programs. To understand how fundamental ES2015 is, just keep in mind that with this version, the specification document went from 250 pages to ~600.\
\
//slide3\
\
The most important changes in ES2015 include: \
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0
\cf4 1. let, const and block scoping\
2. Arrow Functions\
3. Default Function Parameters\
4. Spread / Rest Operator\
5. Object Literal Extensions\
6. Octal and Binary Literals\
7. Array and Object Destructuring\
8. super in Objects\
9. Template Literal and Delimiters\
10. for...of vs for...in\
11. Map and WeakMap\
12. Set and WeakSet\
13. Classes in ES6\
14. Symbol\
15. Iterators\
16. Generators\
17. Promises\
\cf2 Let's take a quick look at each of them.\
\pard\pardeftab720\sl360\qc\partightenfactor0
\cf2 //slide4/1\
\
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0

\f2\b\fs30 \cf4 1. let, const and block scoping\
\pard\pardeftab720\sl320\sa320\qc\partightenfactor0

\f3\b0\fs27\fsmilli13600 \cf4 \cb5 let
\f4\fs32 \cb3 \'a0allows you to create declarations which are bound to any block, called block scoping. \
\pard\pardeftab720\sl360\qc\partightenfactor0

\f1\fs36 \cf2 //slide4/2\
\
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0

\f4\fs32 \cf4 Another form of block-scoped declaration is the\'a0
\f3\fs27\fsmilli13600 \cb5 const
\f4\fs32 \cb3 , which creates constants. In ES6, a\'a0
\f3\fs27\fsmilli13600 \cb5 const
\f4\fs32 \cb3 \'a0represents a constant reference to a value. In other words,\'a0
\f3\fs27\fsmilli13600 \cb5 Object
\f4\fs32 \cb3 's and\'a0
\f3\fs27\fsmilli13600 \cb5 Array
\f4\fs32 \cb3 's contents may change, only the re-assignment of the variable is prevented\
A few things to keep in mind:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl360\qc\partightenfactor0
\cf4 1. Hoisting of\'a0
\f3\fs27\fsmilli13600 \cb5 let
\f4\fs32 \cb3 \'a0and\'a0
\f3\fs27\fsmilli13600 \cb5 const
\f4\fs32 \cb3 \'a0vary from the traditional hoisting of variables and functions. Both\'a0
\f3\fs27\fsmilli13600 \cb5 let
\f4\fs32 \cb3 \'a0and\'a0
\f3\fs27\fsmilli13600 \cb5 const
\f4\fs32 \cb3 \'a0are hoisted, but cannot be accessed before their declaration\

\f1\fs36 \cf2 2.
\f3\fs27\fsmilli13600 \cf4 \cb5 let
\f4\fs32 \cb3 \'a0and\'a0
\f3\fs27\fsmilli13600 \cb5 const
\f4\fs32 \cb3 \'a0are scoped to the nearest enclosing block.\
3. When using const with fixed strings or values, CAPITAL_CASING might be appropriate\
4.
\f3\fs27\fsmilli13600 \cb5 const
\f4\fs32 \cb3 \'a0has to be defined with its declaration\
5. Always use\'a0
\f3\fs27\fsmilli13600 \cb5 const
\f4\fs32 \cb3 \'a0over\'a0
\f3\fs27\fsmilli13600 \cb5 let
\f4\fs32 \cb3 , unless you plan on re-assigning the variable.
\f1\fs36 \cf2 \
\pard\pardeftab720\qc\partightenfactor0
\cf2 \
\pard\pardeftab720\sl360\qc\partightenfactor0
\cf2 //slide5/1\
\
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0

\f2\b\fs30 \cf4 2. Arrow Functions\
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0

\f4\b0\fs32 \cf4 Arrow functions are a short-hand notation for writing functions in ES6. The arrow function definition consists of a parameter list\'a0
\f3\fs27\fsmilli13600 \cb5 ( ... )
\f4\fs32 \cb3 , followed by the\'a0
\f3\fs27\fsmilli13600 \cb5 =>
\f4\fs32 \cb3 \'a0marker and a function body\
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0

\f2\b \cf4 Behold! There is more...\
\pard\pardeftab720\sl360\qc\partightenfactor0

\f1\b0\fs36 \cf2 //slide5/2\
\
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0

\f4\fs32 \cf4 Arrow functions don't just make the code shorter. They are closely related to\'a0
\f3\fs27\fsmilli13600 \cb5 this
\f4\fs32 \cb3 \'a0binding behavior.\
 Each function in JavaScript defines its own\'a0
\f3\fs27\fsmilli13600 \cb5 this
\f4\fs32 \cb3 \'a0context but arrow functions capture the\'a0
\f3\fs27\fsmilli13600 \cb5 this
\f4\fs32 \cb3 \'a0value of the nearest enclosing context\
\pard\pardeftab720\sl360\qc\partightenfactor0

\f1\fs36 \cf2 //slide6\
\
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0

\f2\b\fs30 \cf4 3. Default Function Parameters\
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0

\f4\b0\fs32 \cf4 ES6 allows you to set default parameters in function definitions. Here is a simple illustration.\
\pard\pardeftab720\sl360\qc\partightenfactor0

\f1\fs36 \cf2 //slide7\
\
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0

\f2\b\fs30 \cf4 4. Spread / Rest Operator\
\pard\pardeftab720\sl320\sa320\qc\partightenfactor0

\f4\b0\fs32 \cf4 operator is referred to as spread or rest operator, depending on how and where it is used.\
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0
\cf4 When used with any iterable, it acts as to "spread" it into individual elements:\
When we gathering all arguments together into an array ,it acts call  "rest"\
\pard\pardeftab720\sl360\qc\partightenfactor0

\f1\fs36 \cf2 //slide8\
\
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0

\f2\b\fs30 \cf4 5. Object Literal Extensions\
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0

\f4\b0\fs32 \cf4 ES6 allows declaring object literals by providing shorthand syntax for initializing properties from variables and defining function methods. It also enables the ability to have computed property keys in an object literal definition.\
\pard\pardeftab720\sl360\qc\partightenfactor0

\f1\fs36 \cf2 //slide9\
\
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0

\f2\b\fs30 \cf4 6. Octal and Binary Literals\
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0

\f4\b0\fs32 \cf4 ES6 has new support for octal and binary literals. \
\pard\pardeftab720\sl360\qc\partightenfactor0

\f1\fs36 \cf2 //slide10\
\
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0

\f2\b\fs30 \cf4 7. Array and Object Destructuring\
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0

\f4\b0\fs32 \cf4 Destructuring helps in avoiding the need for temp variables when dealing with object and arrays.\
\pard\pardeftab720\sl360\qc\partightenfactor0

\f1\fs36 \cf2 //slide11\
\
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0

\f2\b\fs30 \cf4 8. super in Objects\
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0

\f4\b0\fs32 \cf4 ES6 allows to use\'a0
\f3\fs27\fsmilli13600 \cb5 super
\f4\fs32 \cb3 \'a0method in (classless) objects with prototypes. \
\pard\pardeftab720\sl360\qc\partightenfactor0

\f1\fs36 \cf2 //slide12\
\
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0

\f2\b\fs30 \cf4 9. Template Literal and Delimiters\
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0

\f4\b0\fs32 \cf4 ES6 introduces an easier way to add interpolations which are evaluated automatically.\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl320\qc\partightenfactor0
\ls1\ilvl0
\f3\fs27\fsmilli13600 \cf4 \cb5 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
`$\{ ... \}`
\f4\fs32 \cb3 \'a0is used for rendering the variables.\cb1 \
\ls1\ilvl0
\f3\fs27\fsmilli13600 \cb5 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
``
\f4\fs32 \cb3 \'a0Backtick is used as delimiter.\
\pard\tx566\pardeftab720\sl320\qc\partightenfactor0

\f1\fs36 \cf2 \cb3 \
\pard\pardeftab720\sl360\qc\partightenfactor0
\cf2 //slide13\
\
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0

\f2\b\fs30 \cf4 10. for...of vs for...in\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl320\qc\partightenfactor0

\f3\b0\fs27\fsmilli13600 \cf4 \cb5 for...of
\f4\fs32 \cb3 \'a0iterates over iterable objects, such as array.\
\

\f3\fs27\fsmilli13600 \cb5 for...in
\f4\fs32 \cb3 \'a0iterates over all enumerable properties of an object.\
\
\pard\pardeftab720\sl360\qc\partightenfactor0

\f1\fs36 \cf2 //slide14/1\
\
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0

\f2\b\fs30 \cf4 11. Map and WeakMap\
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0

\f4\b0\fs32 \cf4 Now, we actually use maps in JavaScript all the time. In fact every object can be considered as a\'a0
\f3\fs27\fsmilli13600 \cb5 Map
\f4\fs32 \cb3 .\
An object is made of keys (always strings) and values, whereas in\'a0
\f3\fs27\fsmilli13600 \cb5 Map
\f4\fs32 \cb3 , any value (both objects and primitive values) may be used as either a key or a value.\
\pard\pardeftab720\sl360\qc\partightenfactor0

\f1\fs36 \cf2 //slide14/2\
\
\pard\pardeftab720\sl360\qc\partightenfactor0

\f2\b\fs32 \cf6 WeakMap\
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0

\f4\b0 \cf4 A\'a0
\f3\fs27\fsmilli13600 \cb5 WeakMap
\f4\fs32 \cb3 \'a0is a Map in which the keys are weakly referenced, that doesn\'92t prevent its keys from being garbage-collected. That means you don't have to worry about memory leaks.\
 In\'a0
\f3\fs27\fsmilli13600 \cb5 WeakMap
\f4\fs32 \cb3 \'a0as opposed to\'a0
\f3\fs27\fsmilli13600 \cb5 Map
\f4\fs32 \cb3 \'a0
\f5\i every key must be an object
\f4\i0 .\
A\'a0
\f3\fs27\fsmilli13600 \cb5 WeakMap
\f4\fs32 \cb3 \'a0only has four methods\'a0
\f3\fs27\fsmilli13600 \cb5 delete(key)
\f4\fs32 \cb3 ,\'a0
\f3\fs27\fsmilli13600 \cb5 has(key)
\f4\fs32 \cb3 ,\'a0
\f3\fs27\fsmilli13600 \cb5 get(key)
\f4\fs32 \cb3 \'a0and\'a0
\f3\fs27\fsmilli13600 \cb5 set(key, value)
\f4\fs32 \cb3 .\
\pard\pardeftab720\sl360\qc\partightenfactor0

\f1\fs36 \cf2 //slide15/1\
\
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0

\f2\b\fs30 \cf4 12. Set and WeakSet\
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0

\f5\i\b0\fs32 \cf4 Set
\f4\i0 \'a0objects are collections of unique values. Duplicate values are ignored. The values can be primitive types or object references.\
\pard\pardeftab720\sl360\qc\partightenfactor0

\f1\fs36 \cf2 //slide15/2\
\
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0

\f4\fs32 \cf4 Similar to\'a0
\f3\fs27\fsmilli13600 \cb5 WeakMap
\f4\fs32 \cb3 , the\'a0
\f3\fs27\fsmilli13600 \cb5 WeakSet
\f4\fs32 \cb3 \'a0object lets you store weakly held\'a0
\f5\i objects
\f4\i0 \'a0in a collection. An object in the\'a0
\f3\fs27\fsmilli13600 \cb5 WeakSet
\f4\fs32 \cb3 \'a0occurs only once; it is unique in the WeakSet's collection.\
\pard\pardeftab720\sl360\qc\partightenfactor0

\f1\fs36 \cf2 //slide16/1\
\
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0
\cf4 13. Classes in ES6\cf2 \
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0

\f4\fs32 \cf4 ES6 introduces new class syntax. One thing to note here is that ES6 class is not a new object-oriented inheritance model. They just serve as a syntactical sugar over JavaScript's existing prototype-based inheritance.\
Functions defined using the\'a0
\f3\fs27\fsmilli13600 \cb5 static
\f4\fs32 \cb3 \'a0keyword implement static/class functions on the class.\
\pard\pardeftab720\sl360\qc\partightenfactor0

\f1\fs36 \cf2 //slide16/2\
\
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0

\f2\b\fs32 \cf4 extends and super in classes\
\pard\pardeftab720\sl320\sa320\qc\partightenfactor0

\f3\b0\fs27\fsmilli13600 \cf4 \cb5 extends
\f4\fs32 \cb3 \'a0allow child class to inherit from parent class in ES6. It is important to note that the derived constructor must call\'a0
\f3\fs27\fsmilli13600 \cb5 super()
\f4\fs32 \cb3 .\
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0
\cf4 Also, you can call parent class's method in child class's methods using\'a0
\f3\fs27\fsmilli13600 \cb5 super.parentMethodName()\
\pard\pardeftab720\sl360\qc\partightenfactor0

\f1\fs36 \cf2 \cb3 //slide17\
\
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0

\f2\b\fs30 \cf4 14. Symbol\
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0

\f4\b0\fs32 \cf4 A\'a0
\f3\fs27\fsmilli13600 \cb5 Symbol
\f4\fs32 \cb3 \'a0is a unique and immutable data type introduced in ES6. The purpose of a symbol is to generate a unique identifier but you can never get any access to that identifier.\
If a symbol is used as a property/key of an object, it\'92s stored in a special way that the property will not show up in a normal enumeration of the object\'92s properties.\
To retrieve an object\'92s symbol properties, use\'a0
\f3\fs27\fsmilli13600 \cb5 Object.getOwnPropertySymbols\
\pard\pardeftab720\sl360\qc\partightenfactor0

\f1\fs36 \cf2 \cb3 //slide18\
\
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0

\f2\b\fs30 \cf4 15. Iterators\
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0

\f4\b0\fs32 \cf4 An iterator accesses the items from a collection one at a time, while keeping track of its current position within that sequence. It provides a\'a0
\f3\fs27\fsmilli13600 \cb5 next()
\f4\fs32 \cb3 \'a0method which returns the next item in the sequence. This method returns an object with two properties: done and value.\
ES6 has\'a0
\f3\fs27\fsmilli13600 \cb5 Symbol.iterator
\f4\fs32 \cb3 \'a0which specifies the default iterator for an object. Whenever an object needs to be iterated (such as at the beginning of a for..of loop), its\'a0
\f5\i @@iterator
\f4\i0 \'a0method is called with no arguments, and the returned iterator is used to obtain the values to be iterated.\
\pard\pardeftab720\sl360\qc\partightenfactor0

\f1\fs36 \cf2 //slide19\
\
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0

\f2\b\fs30 \cf4 16. Generators\
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0

\f4\b0\fs32 \cf4 Generator functions are a new feature in ES6 that allow a function to generate many values over time by returning an object which can be iterated over to pull values from the function one value at a time.\
A generator function returns an\'a0
\f2\b iterable object
\f4\b0 \'a0when it's called. It is written using the new\'a0
\f3\fs27\fsmilli13600 \cb5 *
\f4\fs32 \cb3 \'a0syntax as well as the new\'a0
\f3\fs27\fsmilli13600 \cb5 yield
\f4\fs32 \cb3 \'a0keyword introduced in ES6.\
\pard\pardeftab720\sl360\qc\partightenfactor0

\f1\fs36 \cf2 //slide 20/1\
\
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0

\f2\b\fs30 \cf4 17. Promises\
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0

\f4\b0\fs32 \cf4 ES6 has native support for promises. A\'a0
\f5\i promise
\f4\i0 \'a0is an object that is waiting for an asynchronous operation to complete, and when that operation completes, the promise is either fulfilled(resolved) or rejected.\
\pard\pardeftab720\sl360\qc\partightenfactor0

\f1\fs36 \cf2 //slide 20/2\
\pard\pardeftab720\sl360\qc\partightenfactor0

\f4\fs32 \cf4 \
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0
\cf4 The standard way to create a Promise is by using the\'a0
\f3\fs27\fsmilli13600 \cb5 new Promise()
\f4\fs32 \cb3 \'a0constructor which accepts a handler that is given two functions as parameters. The first handler (typically named\'a0
\f3\fs27\fsmilli13600 \cb5 resolve
\f4\fs32 \cb3 ) is a function to call with the future value when it's ready; and the second handler (typically named\'a0
\f3\fs27\fsmilli13600 \cb5 reject
\f4\fs32 \cb3 ) is a function to call to reject the Promise if it can't resolve the future value.\
Every Promise has a method named\'a0
\f3\fs27\fsmilli13600 \cb5 then
\f4\fs32 \cb3 \'a0which takes a pair of callbacks. The first callback is called if the promise is resolved, while the second is called if the promise is rejected.\
\pard\pardeftab720\sl360\qc\partightenfactor0

\f1\fs36 \cf2 //slide 20/3\
\
\pard\pardeftab720\sl360\sa320\qc\partightenfactor0

\f4\fs32 \cf4 Returning a value from\'a0
\f3\fs27\fsmilli13600 \cb5 then
\f4\fs32 \cb3 \'a0callbacks will pass the value to the next\'a0
\f3\fs27\fsmilli13600 \cb5 then
\f4\fs32 \cb3 \'a0callback.\
When returning a promise, the resolved value of the promise will get passed to the next callback to effectively chain them together. This is a simple technique to avoid "callback hell".\
\pard\pardeftab720\sl360\qc\partightenfactor0

\f1\fs36 \cf2 //slide 21\
\
\pard\pardeftab720\sl360\qc\partightenfactor0

\fs32 \cf2 It was a brief description of all the new features that appeared with the release of ES6. Let's learn and use these features correctly. Thank you and good luck to all.\
\pard\pardeftab720\sl360\qc\partightenfactor0

\f4 \cf4 \
\pard\pardeftab720\sl720\sa600\qc\partightenfactor0

\f1\fs36 \cf2 \
\cf7 \cb8 \
\
\pard\pardeftab720\sl360\qc\partightenfactor0
\cf2 \cb3 \
\
}