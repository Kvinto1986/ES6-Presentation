{\rtf1\ansi\ansicpg1251\cocoartf1671\cocoasubrtf100
{\fonttbl\f0\fnil\fcharset0 HelveticaNeue;\f1\fnil\fcharset0 HelveticaNeue-Bold;\f2\fnil\fcharset0 Menlo-Regular;
}
{\colortbl;\red255\green255\blue255;\red51\green51\blue51;\red254\green254\blue254;\red158\green157\blue157;
\red27\green31\blue34;\red255\green255\blue255;\red21\green23\blue26;\red203\green35\blue57;\red244\green246\blue249;
\red7\green68\blue184;\red91\green40\blue180;\red87\green96\blue106;\red10\green77\blue204;\red6\green33\blue79;
\red218\green76\blue12;}
{\*\expandedcolortbl;;\cssrgb\c25882\c25882\c25882;\cssrgb\c99608\c99608\c99608;\cssrgb\c68235\c67843\c67843;
\cssrgb\c14118\c16078\c18039;\cssrgb\c100000\c100000\c100000;\cssrgb\c10588\c12157\c13725\c4706;\cssrgb\c84314\c22745\c28627;\cssrgb\c96471\c97255\c98039;
\cssrgb\c0\c36078\c77255;\cssrgb\c43529\c25882\c75686;\cssrgb\c41569\c45098\c49020;\cssrgb\c1176\c40000\c83922;\cssrgb\c1176\c18431\c38431;
\cssrgb\c89020\c38431\c3529;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid101\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid201\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid3}
{\list\listtemplateid4\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid301\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid4}
{\list\listtemplateid5\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid401\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid5}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}{\listoverride\listid4\listoverridecount0\ls4}{\listoverride\listid5\listoverridecount0\ls5}}
\paperw11900\paperh16840\margl1440\margr1440\vieww37900\viewh21300\viewkind0
\deftab720
\pard\pardeftab720\sl720\sa600\qc\partightenfactor0

\f0\fs40 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 ECMAScript 2015, also known as ES6, is a fundamental version of the ECMAScript standard.\

\f1\b Published 4 years after the latest standard revision
\f0\b0 , ECMAScript 5.1, it also marked the switch from edition number to year number.\
So\'a0
\f1\b it should not be named as ES6
\f0\b0 \'a0(although everyone calls it as such) but ES2015 instead.\
\pard\pardeftab720\sl720\qc\partightenfactor0

\i \cf4 \strokec4 ES5 was 10 years in the making, from 1999 to 2009, and as such it was also a fundamental and very important revision of the language, but now much time has passed that it\'92s not worth discussing how pre-ES5 code worked.\cb1 \
\pard\pardeftab720\sl720\sa600\qc\partightenfactor0

\i0 \cf2 \cb3 \strokec2 Since this long time passed between ES5.1 and ES6, the release is full of important new features and major changes in suggested best practices in developing JavaScript programs. To understand how fundamental ES2015 is, just keep in mind that with this version, the specification document went from 250 pages to ~600.\
The most important changes in ES2015 include\
\pard\pardeftab720\sl360\sa320\partightenfactor0

\b\fs30 \cf5 \cb6 \strokec5 1. let, const and block scoping\
\pard\pardeftab720\sl320\sa320\partightenfactor0

\f2\b0\fs27\fsmilli13600 \cf5 \cb7 let
\f0\fs32 \cb6 \'a0allows you to create declarations which are bound to any block, called block scoping. Instead of using\'a0
\f2\fs27\fsmilli13600 \cb7 var
\f0\fs32 \cb6 , which provides function scope, it is recommended to use block scoped variables (
\f2\fs27\fsmilli13600 \cb7 let
\f0\fs32 \cb6 \'a0or\'a0
\f2\fs27\fsmilli13600 \cb7 const
\f0\fs32 \cb6 ) in ES6.\
\pard\pardeftab720\sl380\partightenfactor0

\f2\fs27\fsmilli13600 \cf8 \cb9 \strokec8 var\cf5 \strokec5  a \cf8 \strokec8 =\cf5 \strokec5  \cf10 \strokec10 2\cf5 \strokec5 ;\
\{\
    \cf8 \strokec8 let\cf5 \strokec5  a \cf8 \strokec8 =\cf5 \strokec5  \cf10 \strokec10 3\cf5 \strokec5 ;\
    \cf11 \strokec11 console\cf5 \strokec5 .\cf10 \strokec10 log\cf5 \strokec5 (a); \cf12 \strokec12 // 3\cf5 \strokec5 \
    \cf8 \strokec8 let\cf5 \strokec5  a \cf8 \strokec8 =\cf5 \strokec5  \cf10 \strokec10 5\cf5 \strokec5 ; \cf12 \strokec12 // TypeError: Identifier 'a' has already been declared\cf5 \strokec5 \
\}\
\pard\pardeftab720\sl380\partightenfactor0
\cf11 \strokec11 console\cf5 \strokec5 .\cf10 \strokec10 log\cf5 \strokec5 (a); \cf12 \strokec12 // 2\cf5 \strokec5 \
\pard\pardeftab720\sl360\sa320\partightenfactor0

\f0\fs32 \cf5 \cb6 Another form of block-scoped declaration is the\'a0
\f2\fs27\fsmilli13600 \cb7 const
\f0\fs32 \cb6 , which creates constants. In ES6, a\'a0
\f2\fs27\fsmilli13600 \cb7 const
\f0\fs32 \cb6 \'a0represents a constant reference to a value. In other words,\'a0
\f2\fs27\fsmilli13600 \cb7 Object
\f0\fs32 \cb6 's and\'a0
\f2\fs27\fsmilli13600 \cb7 Array
\f0\fs32 \cb6 's contents may change, only the re-assignment of the variable is prevented. Here's a simple example:\
\pard\pardeftab720\sl380\partightenfactor0

\f2\fs27\fsmilli13600 \cf5 \cb9 \{\
    \cf8 \strokec8 const\cf5 \strokec5  \cf10 \strokec10 b\cf5 \strokec5  \cf8 \strokec8 =\cf5 \strokec5  \cf10 \strokec10 5\cf5 \strokec5 ;\
    b \cf8 \strokec8 =\cf5 \strokec5  \cf10 \strokec10 10\cf5 \strokec5 ; \cf12 \strokec12 // TypeError: Assignment to constant variable\cf5 \strokec5 \
\
    \cf8 \strokec8 const\cf5 \strokec5  \cf10 \strokec10 arr\cf5 \strokec5  \cf8 \strokec8 =\cf5 \strokec5  [\cf10 \strokec10 5\cf5 \strokec5 , \cf10 \strokec10 6\cf5 \strokec5 ];\
    arr.\cf10 \strokec10 push\cf5 \strokec5 (\cf10 \strokec10 7\cf5 \strokec5 );\
    \cf11 \strokec11 console\cf5 \strokec5 .\cf10 \strokec10 log\cf5 \strokec5 (arr); \cf12 \strokec12 // [5,6,7]\cf5 \strokec5 \
    arr \cf8 \strokec8 =\cf5 \strokec5  \cf10 \strokec10 10\cf5 \strokec5 ; \cf12 \strokec12 // TypeError: Assignment to constant variable\cf5 \strokec5 \
    arr[\cf10 \strokec10 0\cf5 \strokec5 ] \cf8 \strokec8 =\cf5 \strokec5  \cf10 \strokec10 3\cf5 \strokec5 ; \cf12 \strokec12 // value is mutable\cf5 \strokec5 \
    \cf11 \strokec11 console\cf5 \strokec5 .\cf10 \strokec10 log\cf5 \strokec5 (arr); \cf12 \strokec12 // [3,6,7]\cf5 \strokec5 \
\}\
\pard\pardeftab720\sl360\sa320\partightenfactor0

\f0\fs32 \cf5 \cb6 A few things to keep in mind:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl360\partightenfactor0
\ls1\ilvl0\cf5 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec5 Hoisting of\'a0
\f2\fs27\fsmilli13600 \cb7 let
\f0\fs32 \cb6 \'a0and\'a0
\f2\fs27\fsmilli13600 \cb7 const
\f0\fs32 \cb6 \'a0vary from the traditional hoisting of variables and functions. Both\'a0
\f2\fs27\fsmilli13600 \cb7 let
\f0\fs32 \cb6 \'a0and\'a0
\f2\fs27\fsmilli13600 \cb7 const
\f0\fs32 \cb6 \'a0are hoisted, but cannot be accessed before their declaration, because of\'a0{\field{\*\fldinst{HYPERLINK "http://jsrocks.org/2015/01/temporal-dead-zone-tdz-demystified"}}{\fldrslt \cf13 \strokec13 Temporal Dead Zone}}\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl320\partightenfactor0
\ls1\ilvl0
\f2\fs27\fsmilli13600 \cf5 \cb7 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec5 let
\f0\fs32 \cb6 \'a0and\'a0
\f2\fs27\fsmilli13600 \cb7 const
\f0\fs32 \cb6 \'a0are scoped to the nearest enclosing block.\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl360\partightenfactor0
\ls1\ilvl0\cf5 \cb6 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec5 When using const with fixed strings or values, CAPITAL_CASING might be appropriate (ex:\'a0
\f2\fs27\fsmilli13600 \cb7 const PI = 3.14
\f0\fs32 \cb6 )\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl320\partightenfactor0
\ls1\ilvl0
\f2\fs27\fsmilli13600 \cf5 \cb7 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec5 const
\f0\fs32 \cb6 \'a0has to be defined with its declaration.\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl360\partightenfactor0
\ls1\ilvl0\cf5 \cb6 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec5 Always use\'a0
\f2\fs27\fsmilli13600 \cb7 const
\f0\fs32 \cb6 \'a0over\'a0
\f2\fs27\fsmilli13600 \cb7 let
\f0\fs32 \cb6 , unless you plan on re-assigning the variable.\cb1 \
\pard\pardeftab720\sl360\partightenfactor0
\cf5 \cb6 \
\pard\pardeftab720\sl300\partightenfactor0

\b\fs30 \cf13 \cb1 \strokec13 \
\pard\pardeftab720\sl360\sa320\partightenfactor0
\cf5 \cb6 \strokec5 2. Arrow Functions\
\pard\pardeftab720\sl360\sa320\partightenfactor0

\b0\fs32 \cf5 Arrow functions are a short-hand notation for writing functions in ES6. The arrow function definition consists of a parameter list\'a0
\f2\fs27\fsmilli13600 \cb7 ( ... )
\f0\fs32 \cb6 , followed by the\'a0
\f2\fs27\fsmilli13600 \cb7 =>
\f0\fs32 \cb6 \'a0marker and a function body. For single-argument functions, the parentheses may be omitted.\
\pard\pardeftab720\sl380\partightenfactor0

\f2\fs27\fsmilli13600 \cf12 \cb9 \strokec12 // Classical Function Expression\cf5 \strokec5 \
\pard\pardeftab720\sl380\partightenfactor0
\cf8 \strokec8 function\cf5 \strokec5  \cf11 \strokec11 addition\cf5 \strokec5 (a, b) \{\
    \cf8 \strokec8 return\cf5 \strokec5  a \cf8 \strokec8 +\cf5 \strokec5  b;\
\};\
\
\pard\pardeftab720\sl380\partightenfactor0
\cf12 \strokec12 // Implementation with arrow function\cf5 \strokec5 \
\pard\pardeftab720\sl380\partightenfactor0
\cf8 \strokec8 const\cf5 \strokec5  \cf10 \strokec10 addition\cf5 \strokec5  \cf8 \strokec8 =\cf5 \strokec5  (a, b) \cf8 \strokec8 =>\cf5 \strokec5  a \cf8 \strokec8 +\cf5 \strokec5  b;\
\
\pard\pardeftab720\sl380\partightenfactor0
\cf12 \strokec12 // With single argument, no parentheses required\cf5 \strokec5 \
\pard\pardeftab720\sl380\partightenfactor0
\cf8 \strokec8 const\cf5 \strokec5  \cf10 \strokec10 add5\cf5 \strokec5  \cf8 \strokec8 =\cf5 \strokec5  a \cf8 \strokec8 =>\cf5 \strokec5  \cf10 \strokec10 5\cf5 \strokec5  \cf8 \strokec8 +\cf5 \strokec5  a;\
\pard\pardeftab720\sl360\sa320\partightenfactor0

\f0\fs32 \cf5 \cb6 Note that in the above example, the\'a0
\f2\fs27\fsmilli13600 \cb7 addition
\f0\fs32 \cb6 \'a0arrow function is implemented with "concise body" which does not need an explicit return statement. Note the omitted\'a0
\f2\fs27\fsmilli13600 \cb7 \{ \}
\f0\fs32 \cb6 \'a0after the\'a0
\f2\fs27\fsmilli13600 \cb7 =>
\f0\fs32 \cb6 .\
Here is an example with the usual "block body." Including the curly brace wrappers.\
\pard\pardeftab720\sl380\partightenfactor0

\f2\fs27\fsmilli13600 \cf8 \cb9 \strokec8 const\cf5 \strokec5  \cf10 \strokec10 arr\cf5 \strokec5  \cf8 \strokec8 =\cf5 \strokec5  [\cf14 \strokec14 'apple'\cf5 \strokec5 , \cf14 \strokec14 'banana'\cf5 \strokec5 , \cf14 \strokec14 'orange'\cf5 \strokec5 ];\
\
\cf8 \strokec8 const\cf5 \strokec5  \cf10 \strokec10 breakfast\cf5 \strokec5  \cf8 \strokec8 =\cf5 \strokec5  arr.\cf11 \strokec11 map\cf5 \strokec5 (fruit \cf8 \strokec8 =>\cf5 \strokec5  \{\
    \cf8 \strokec8 return\cf5 \strokec5  fruit \cf8 \strokec8 +\cf5 \strokec5  \cf14 \strokec14 's'\cf5 \strokec5 ;\
\});\
\
\pard\pardeftab720\sl380\partightenfactor0
\cf11 \strokec11 console\cf5 \strokec5 .\cf10 \strokec10 log\cf5 \strokec5 (breakfast); \cf12 \strokec12 // ['apples', 'bananas', 'oranges']\cf5 \strokec5 \
\pard\pardeftab720\sl360\sa320\partightenfactor0

\f0\b\fs32 \cf5 \cb6 Behold! There is more...
\b0 \
Arrow functions don't just make the code shorter. They are closely related to\'a0
\f2\fs27\fsmilli13600 \cb7 this
\f0\fs32 \cb6 \'a0binding behavior.\
Arrow functions behavior with\'a0
\f2\fs27\fsmilli13600 \cb7 this
\f0\fs32 \cb6 \'a0keyword varies from that of normal functions. Each function in JavaScript defines its own\'a0
\f2\fs27\fsmilli13600 \cb7 this
\f0\fs32 \cb6 \'a0context but arrow functions capture the\'a0
\f2\fs27\fsmilli13600 \cb7 this
\f0\fs32 \cb6 \'a0value of the nearest enclosing context. Check out the following code:\
\pard\pardeftab720\sl380\partightenfactor0

\f2\fs27\fsmilli13600 \cf8 \cb9 \strokec8 function\cf5 \strokec5  \cf11 \strokec11 Person\cf5 \strokec5 () \{\
    \cf12 \strokec12 // The Person() constructor defines `this` as an instance of itself.\cf5 \strokec5 \
    \cf10 \strokec10 this\cf5 \strokec5 .age \cf8 \strokec8 =\cf5 \strokec5  \cf10 \strokec10 0\cf5 \strokec5 ;\
\
    \cf10 \strokec10 setInterval\cf5 \strokec5 (\cf8 \strokec8 function\cf5 \strokec5  \cf11 \strokec11 growUp\cf5 \strokec5 () \{\
        \cf12 \strokec12 // In non-strict mode, the growUp() function defines `this`\cf5 \strokec5 \
        \cf12 \strokec12 // as the global object, which is different from the `this`\cf5 \strokec5 \
        \cf12 \strokec12 // defined by the Person() constructor.\cf5 \strokec5 \
        \cf10 \strokec10 this\cf5 \strokec5 .age\cf8 \strokec8 ++\cf5 \strokec5 ;\
    \}, \cf10 \strokec10 1000\cf5 \strokec5 );\
\}\
\cf8 \strokec8 var\cf5 \strokec5  p \cf8 \strokec8 =\cf5 \strokec5  \cf8 \strokec8 new\cf5 \strokec5  \cf11 \strokec11 Person\cf5 \strokec5 ();\
\pard\pardeftab720\sl360\sa320\partightenfactor0

\f0\fs32 \cf5 \cb6 In ECMAScript 3/5, this issue was fixed by assigning the value in\'a0
\f2\fs27\fsmilli13600 \cb7 this
\f0\fs32 \cb6 \'a0to a variable that could be closed over.\
\pard\pardeftab720\sl380\partightenfactor0

\f2\fs27\fsmilli13600 \cf8 \cb9 \strokec8 function\cf5 \strokec5  \cf11 \strokec11 Person\cf5 \strokec5 () \{\
    \cf8 \strokec8 const\cf5 \strokec5  \cf10 \strokec10 self\cf5 \strokec5  \cf8 \strokec8 =\cf5 \strokec5  \cf10 \strokec10 this\cf5 \strokec5 ;\
    self.age \cf8 \strokec8 =\cf5 \strokec5  \cf10 \strokec10 0\cf5 \strokec5 ;\
\
    \cf10 \strokec10 setInterval\cf5 \strokec5 (\cf8 \strokec8 function\cf5 \strokec5  \cf11 \strokec11 growUp\cf5 \strokec5 () \{\
        \cf12 \strokec12 // The callback refers to the `self` variable of which\cf5 \strokec5 \
        \cf12 \strokec12 // the value is the expected object.\cf5 \strokec5 \
        self.age\cf8 \strokec8 ++\cf5 \strokec5 ;\
    \}, \cf10 \strokec10 1000\cf5 \strokec5 );\
\}\
\pard\pardeftab720\sl360\sa320\partightenfactor0

\f0\fs32 \cf5 \cb6 As mentioned above, arrow functions capture the this value of the nearest enclosing context, so the following code works as expected, even with nested arrow functions.\
\pard\pardeftab720\sl380\partightenfactor0

\f2\fs27\fsmilli13600 \cf8 \cb9 \strokec8 function\cf5 \strokec5  \cf11 \strokec11 Person\cf5 \strokec5 () \{\
    \cf10 \strokec10 this\cf5 \strokec5 .age \cf8 \strokec8 =\cf5 \strokec5  \cf10 \strokec10 0\cf5 \strokec5 ;\
\
    \cf10 \strokec10 setInterval\cf5 \strokec5 (() \cf8 \strokec8 =>\cf5 \strokec5  \{\
        \cf10 \strokec10 setTimeout\cf5 \strokec5 (() \cf8 \strokec8 =>\cf5 \strokec5  \{\
            \cf10 \strokec10 this\cf5 \strokec5 .age\cf8 \strokec8 ++\cf5 \strokec5 ; \cf12 \strokec12 // `this` properly refers to the person object\cf5 \strokec5 \
        \}, \cf10 \strokec10 1000\cf5 \strokec5 );\
    \}, \cf10 \strokec10 1000\cf5 \strokec5 );\
\}\
\
\cf8 \strokec8 let\cf5 \strokec5  p \cf8 \strokec8 =\cf5 \strokec5  \cf8 \strokec8 new\cf5 \strokec5  \cf11 \strokec11 Person\cf5 \strokec5 ();\
\pard\pardeftab720\sl360\sa320\partightenfactor0
{\field{\*\fldinst{HYPERLINK "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#No_binding_of_this"}}{\fldrslt 
\f0\fs32 \cf13 \cb6 \strokec13 Read more about 'Lexical this' in arrow functions here}}
\f0\fs32 \cb6 \
\pard\pardeftab720\sl360\partightenfactor0
\cf5 \
\pard\pardeftab720\sl300\partightenfactor0

\b\fs30 \cf13 \cb1 \strokec13 \
\pard\pardeftab720\sl360\sa320\partightenfactor0
\cf5 \cb6 \strokec5 3. Default Function Parameters\
\pard\pardeftab720\sl360\sa320\partightenfactor0

\b0\fs32 \cf5 ES6 allows you to set default parameters in function definitions. Here is a simple illustration.\
\pard\pardeftab720\sl380\partightenfactor0

\f2\fs27\fsmilli13600 \cf8 \cb9 \strokec8 const\cf5 \strokec5  \cf10 \strokec10 getFinalPrice\cf5 \strokec5  \cf8 \strokec8 =\cf5 \strokec5  (price, tax \cf8 \strokec8 =\cf5 \strokec5  \cf10 \strokec10 0.7\cf5 \strokec5 ) \cf8 \strokec8 =>\cf5 \strokec5  price \cf8 \strokec8 +\cf5 \strokec5  price \cf8 \strokec8 *\cf5 \strokec5  tax;\
\pard\pardeftab720\sl380\partightenfactor0
\cf11 \strokec11 getFinalPrice\cf5 \strokec5 (\cf10 \strokec10 500\cf5 \strokec5 ); \cf12 \strokec12 // 850\cf5 \strokec5 \
\pard\pardeftab720\sl360\partightenfactor0

\f0\fs32 \cf5 \cb6 \
\pard\pardeftab720\sl300\partightenfactor0

\b\fs30 \cf13 \cb1 \strokec13 \
\pard\pardeftab720\sl360\sa320\partightenfactor0
\cf5 \cb6 \strokec5 4. Spread / Rest Operator\
\pard\pardeftab720\sl320\sa320\partightenfactor0

\f2\b0\fs27\fsmilli13600 \cf5 \cb7 ...
\f0\fs32 \cb6 \'a0operator is referred to as spread or rest operator, depending on how and where it is used.\
\pard\pardeftab720\sl360\sa320\partightenfactor0
\cf5 When used with any iterable, it acts as to "spread" it into individual elements:\
\pard\pardeftab720\sl380\partightenfactor0

\f2\fs27\fsmilli13600 \cf8 \cb9 \strokec8 const\cf5 \strokec5  \cf10 \strokec10 makeToast\cf5 \strokec5  \cf8 \strokec8 =\cf5 \strokec5  (breadType, topping1, topping2) \cf8 \strokec8 =>\cf5 \strokec5  \{\
  \cf8 \strokec8 return\cf5 \strokec5  \cf14 \strokec14 `I had \cf5 \strokec5 $\{breadType\}\cf14 \strokec14  toast with \cf5 \strokec5 $\{topping1\}\cf14 \strokec14  and \cf5 \strokec5 $\{topping2\}\cf14 \strokec14 `\cf5 \strokec5 ;\
\};\
\cf8 \strokec8 const\cf5 \strokec5  \cf10 \strokec10 ingredients\cf5 \strokec5  \cf8 \strokec8 =\cf5 \strokec5  [\cf14 \strokec14 'wheat'\cf5 \strokec5 , \cf14 \strokec14 'butter'\cf5 \strokec5 , \cf14 \strokec14 'jam'\cf5 \strokec5 ];\
\pard\pardeftab720\sl380\partightenfactor0
\cf11 \strokec11 makeToast\cf5 \strokec5 (\cf8 \strokec8 ...\cf5 \strokec5 ingredients);\
\pard\pardeftab720\sl380\partightenfactor0
\cf12 \strokec12 // "I had wheat toast with butter and jam"\cf5 \strokec5 \
\
\pard\pardeftab720\sl380\partightenfactor0
\cf11 \strokec11 makeToast\cf5 \strokec5 (\cf8 \strokec8 ...\cf5 \strokec5 [\cf14 \strokec14 'sourdough'\cf5 \strokec5 , \cf14 \strokec14 'avocado'\cf5 \strokec5 , \cf14 \strokec14 'kale'\cf5 \strokec5 ]);\
\pard\pardeftab720\sl380\partightenfactor0
\cf12 \strokec12 // "I had sourdough toast with avocado and kale"\cf5 \strokec5 \
\pard\pardeftab720\sl360\sa320\partightenfactor0

\f0\fs32 \cf5 \cb6 Spread is also great for shaping a new object from other object(s):\
\pard\pardeftab720\sl380\partightenfactor0

\f2\fs27\fsmilli13600 \cf8 \cb9 \strokec8 const\cf5 \strokec5  \cf10 \strokec10 defaults\cf5 \strokec5  \cf8 \strokec8 =\cf5 \strokec5  \{avatar\cf8 \strokec8 :\cf5 \strokec5  \cf14 \strokec14 'placeholder.jpg'\cf5 \strokec5 , active\cf8 \strokec8 :\cf5 \strokec5  \cf10 \strokec10 false\cf5 \strokec5 \}\
\cf8 \strokec8 const\cf5 \strokec5  \cf10 \strokec10 userData\cf5 \strokec5  \cf8 \strokec8 =\cf5 \strokec5  \{username\cf8 \strokec8 :\cf5 \strokec5  \cf14 \strokec14 'foo'\cf5 \strokec5 , avatar\cf8 \strokec8 :\cf5 \strokec5  \cf14 \strokec14 'bar.jpg'\cf5 \strokec5 \}\
\
\pard\pardeftab720\sl380\partightenfactor0
\cf11 \strokec11 console\cf5 \strokec5 .\cf10 \strokec10 log\cf5 \strokec5 (\{created\cf8 \strokec8 :\cf5 \strokec5  \cf14 \strokec14 '2017-12-31'\cf5 \strokec5 , \cf8 \strokec8 ...\cf5 \strokec5 defaults, \cf8 \strokec8 ...\cf5 \strokec5 userData\})\
\pard\pardeftab720\sl380\partightenfactor0
\cf12 \strokec12 // \{created: "2017-12-31", avatar: "bar.jpg", active: false, username: "foo"\}\cf5 \strokec5 \
\pard\pardeftab720\sl360\sa320\partightenfactor0

\f0\fs32 \cf5 \cb6 New arrays can also be shaped expressively:\
\pard\pardeftab720\sl380\partightenfactor0

\f2\fs27\fsmilli13600 \cf8 \cb9 \strokec8 const\cf5 \strokec5  \cf10 \strokec10 arr1\cf5 \strokec5  \cf8 \strokec8 =\cf5 \strokec5  [\cf10 \strokec10 1\cf5 \strokec5 , \cf10 \strokec10 2\cf5 \strokec5 , \cf10 \strokec10 3\cf5 \strokec5 ];\
\cf8 \strokec8 const\cf5 \strokec5  \cf10 \strokec10 arr2\cf5 \strokec5  \cf8 \strokec8 =\cf5 \strokec5  [\cf10 \strokec10 7\cf5 \strokec5 , \cf10 \strokec10 8\cf5 \strokec5 , \cf10 \strokec10 9\cf5 \strokec5 ];\
\pard\pardeftab720\sl380\partightenfactor0
\cf11 \strokec11 console\cf5 \strokec5 .\cf10 \strokec10 log\cf5 \strokec5 ([\cf8 \strokec8 ...\cf5 \strokec5 arr1, \cf10 \strokec10 4\cf5 \strokec5 , \cf10 \strokec10 5\cf5 \strokec5 , \cf10 \strokec10 6\cf5 \strokec5 , \cf8 \strokec8 ...\cf5 \strokec5 arr2]) \cf12 \strokec12 // [1, 2, 3, 4, 5, 6, 7, 8, 9]\cf5 \strokec5 \
\pard\pardeftab720\sl360\sa320\partightenfactor0

\f0\fs32 \cf5 \cb6 The other common usage of\'a0
\f2\fs27\fsmilli13600 \cb7 ...
\f0\fs32 \cb6 \'a0is gathering all arguments together into an array. This is referred as "rest" operator.\
\pard\pardeftab720\sl380\partightenfactor0

\f2\fs27\fsmilli13600 \cf8 \cb9 \strokec8 function\cf5 \strokec5  \cf11 \strokec11 foo\cf5 \strokec5 (\cf8 \strokec8 ...\cf15 \strokec15 args\cf5 \strokec5 ) \{\
    \cf11 \strokec11 console\cf5 \strokec5 .\cf10 \strokec10 log\cf5 \strokec5 (args);\
\}\
\pard\pardeftab720\sl380\partightenfactor0
\cf11 \strokec11 foo\cf5 \strokec5 (\cf10 \strokec10 1\cf5 \strokec5 , \cf10 \strokec10 2\cf5 \strokec5 , \cf10 \strokec10 3\cf5 \strokec5 , \cf10 \strokec10 4\cf5 \strokec5 , \cf10 \strokec10 5\cf5 \strokec5 ); \cf12 \strokec12 // [1, 2, 3, 4, 5]\cf5 \strokec5 \
\pard\pardeftab720\sl360\partightenfactor0

\f0\fs32 \cf5 \cb6 \
\pard\pardeftab720\sl300\partightenfactor0

\b\fs30 \cf13 \cb1 \strokec13 \
\pard\pardeftab720\sl360\sa320\partightenfactor0
\cf5 \cb6 \strokec5 5. Object Literal Extensions\
\pard\pardeftab720\sl360\sa320\partightenfactor0

\b0\fs32 \cf5 ES6 allows declaring object literals by providing shorthand syntax for initializing properties from variables and defining function methods. It also enables the ability to have computed property keys in an object literal definition.\
\pard\pardeftab720\sl380\partightenfactor0

\f2\fs27\fsmilli13600 \cf8 \cb9 \strokec8 function\cf5 \strokec5  \cf11 \strokec11 getCar\cf5 \strokec5 (make, model, value) \{\
    \cf8 \strokec8 return\cf5 \strokec5  \{\
        \cf12 \strokec12 // with property value shorthand\cf5 \strokec5 \
        \cf12 \strokec12 // syntax, you can omit the property\cf5 \strokec5 \
        \cf12 \strokec12 // value if key matches variable\cf5 \strokec5 \
        \cf12 \strokec12 // name\cf5 \strokec5 \
        make,  \cf12 \strokec12 // same as make: make\cf5 \strokec5 \
        model, \cf12 \strokec12 // same as model: model\cf5 \strokec5 \
        value, \cf12 \strokec12 // same as value: value\cf5 \strokec5 \
\
        \cf12 \strokec12 // computed values now work with\cf5 \strokec5 \
        \cf12 \strokec12 // object literals\cf5 \strokec5 \
        [\cf14 \strokec14 'make'\cf5 \strokec5  \cf8 \strokec8 +\cf5 \strokec5  make]\cf8 \strokec8 :\cf5 \strokec5  \cf10 \strokec10 true\cf5 \strokec5 ,\
\
        \cf12 \strokec12 // Method definition shorthand syntax\cf5 \strokec5 \
        \cf12 \strokec12 // omits `function` keyword & colon\cf5 \strokec5 \
        \cf11 \strokec11 depreciate\cf5 \strokec5 () \{\
            \cf10 \strokec10 this\cf5 \strokec5 .\cf10 \strokec10 value\cf5 \strokec5  \cf8 \strokec8 -=\cf5 \strokec5  \cf10 \strokec10 2500\cf5 \strokec5 ;\
        \}\
    \};\
\}\
\
\cf8 \strokec8 let\cf5 \strokec5  car \cf8 \strokec8 =\cf5 \strokec5  \cf11 \strokec11 getCar\cf5 \strokec5 (\cf14 \strokec14 'Kia'\cf5 \strokec5 , \cf14 \strokec14 'Sorento'\cf5 \strokec5 , \cf10 \strokec10 40000\cf5 \strokec5 );\
\pard\pardeftab720\sl380\partightenfactor0
\cf11 \strokec11 console\cf5 \strokec5 .\cf10 \strokec10 log\cf5 \strokec5 (car);\
\pard\pardeftab720\sl380\partightenfactor0
\cf12 \strokec12 // \{\cf5 \strokec5 \
\cf12 \strokec12 //     make: 'Kia',\cf5 \strokec5 \
\cf12 \strokec12 //     model:'Sorento',\cf5 \strokec5 \
\cf12 \strokec12 //     value: 40000,\cf5 \strokec5 \
\cf12 \strokec12 //     makeKia: true,\cf5 \strokec5 \
\cf12 \strokec12 //     depreciate: function()\cf5 \strokec5 \
\cf12 \strokec12 // \}\cf5 \strokec5 \
\pard\pardeftab720\sl360\partightenfactor0

\f0\fs32 \cf5 \cb6 \
\pard\pardeftab720\sl300\partightenfactor0

\b\fs30 \cf13 \cb1 \strokec13 \
\pard\pardeftab720\sl360\sa320\partightenfactor0
\cf5 \cb6 \strokec5 6. Octal and Binary Literals\
\pard\pardeftab720\sl360\sa320\partightenfactor0

\b0\fs32 \cf5 ES6 has new support for octal and binary literals. Prependending a number with\'a0
\f2\fs27\fsmilli13600 \cb7 0o
\f0\fs32 \cb6 \'a0or\'a0
\f2\fs27\fsmilli13600 \cb7 0O
\f0\fs32 \cb6 \'a0would convert it into octal value. Have a look at the following code:\
\pard\pardeftab720\sl380\partightenfactor0

\f2\fs27\fsmilli13600 \cf8 \cb9 \strokec8 let\cf5 \strokec5  oValue \cf8 \strokec8 =\cf5 \strokec5  \cf10 \strokec10 0o10\cf5 \strokec5 ;\
\pard\pardeftab720\sl380\partightenfactor0
\cf11 \strokec11 console\cf5 \strokec5 .\cf10 \strokec10 log\cf5 \strokec5 (oValue); \cf12 \strokec12 // 8\cf5 \strokec5 \
\
\pard\pardeftab720\sl380\partightenfactor0
\cf8 \strokec8 let\cf5 \strokec5  bValue \cf8 \strokec8 =\cf5 \strokec5  \cf10 \strokec10 0b10\cf5 \strokec5 ; \cf12 \strokec12 // 0b or 0B for binary\cf5 \strokec5 \
\pard\pardeftab720\sl380\partightenfactor0
\cf11 \strokec11 console\cf5 \strokec5 .\cf10 \strokec10 log\cf5 \strokec5 (bValue); \cf12 \strokec12 // 2\cf5 \strokec5 \
\pard\pardeftab720\sl360\partightenfactor0

\f0\fs32 \cf5 \cb6 \
\pard\pardeftab720\sl300\partightenfactor0

\b\fs30 \cf13 \cb1 \strokec13 \
\pard\pardeftab720\sl360\sa320\partightenfactor0
\cf5 \cb6 \strokec5 7. Array and Object Destructuring\
\pard\pardeftab720\sl360\sa320\partightenfactor0

\b0\fs32 \cf5 Destructuring helps in avoiding the need for temp variables when dealing with object and arrays.\
\pard\pardeftab720\sl380\partightenfactor0

\f2\fs27\fsmilli13600 \cf8 \cb9 \strokec8 function\cf5 \strokec5  \cf11 \strokec11 foo\cf5 \strokec5 () \{\
    \cf8 \strokec8 return\cf5 \strokec5  [\cf10 \strokec10 1\cf5 \strokec5 , \cf10 \strokec10 2\cf5 \strokec5 , \cf10 \strokec10 3\cf5 \strokec5 ];\
\}\
\cf8 \strokec8 let\cf5 \strokec5  arr \cf8 \strokec8 =\cf5 \strokec5  \cf11 \strokec11 foo\cf5 \strokec5 (); \cf12 \strokec12 // [1,2,3]\cf5 \strokec5 \
\
\cf8 \strokec8 let\cf5 \strokec5  [a, b, c] \cf8 \strokec8 =\cf5 \strokec5  \cf11 \strokec11 foo\cf5 \strokec5 ();\
\pard\pardeftab720\sl380\partightenfactor0
\cf11 \strokec11 console\cf5 \strokec5 .\cf10 \strokec10 log\cf5 \strokec5 (a, b, c); \cf12 \strokec12 // 1 2 3\cf5 \strokec5 \
\pard\pardeftab720\sl380\partightenfactor0
\cf8 \strokec8 function\cf5 \strokec5  \cf11 \strokec11 getCar\cf5 \strokec5 () \{\
  \cf8 \strokec8 return\cf5 \strokec5  \{\
    make\cf8 \strokec8 :\cf5 \strokec5  \cf14 \strokec14 'Tesla'\cf5 \strokec5 ,\
    model\cf8 \strokec8 :\cf5 \strokec5  \cf14 \strokec14 'g95'\cf5 \strokec5 ,\
    metadata\cf8 \strokec8 :\cf5 \strokec5  \{\
      vin\cf8 \strokec8 :\cf5 \strokec5  \cf14 \strokec14 '123abc'\cf5 \strokec5 ,\
      miles\cf8 \strokec8 :\cf5 \strokec5  \cf14 \strokec14 '12000'\cf5 \strokec5 \
    \}\
  \};\
\}\
\
\cf8 \strokec8 const\cf5 \strokec5  \{\cf10 \strokec10 make\cf5 \strokec5 , \cf10 \strokec10 model\cf5 \strokec5 \} \cf8 \strokec8 =\cf5 \strokec5  \cf11 \strokec11 getCar\cf5 \strokec5 ();\
\pard\pardeftab720\sl380\partightenfactor0
\cf11 \strokec11 console\cf5 \strokec5 .\cf10 \strokec10 log\cf5 \strokec5 (make, model); \cf12 \strokec12 // Tesla g95\cf5 \strokec5 \
\
\pard\pardeftab720\sl380\partightenfactor0
\cf8 \strokec8 const\cf5 \strokec5  \{\cf10 \strokec10 make\cf5 \strokec5 , metadata\cf8 \strokec8 :\cf5 \strokec5  \{\cf10 \strokec10 miles\cf5 \strokec5 \}\} \cf8 \strokec8 =\cf5 \strokec5  \cf11 \strokec11 getCar\cf5 \strokec5 ();\
\pard\pardeftab720\sl380\partightenfactor0
\cf11 \strokec11 console\cf5 \strokec5 .\cf10 \strokec10 log\cf5 \strokec5 (make, miles); \cf12 \strokec12 // Tesla 12000\cf5 \strokec5 \
\
\pard\pardeftab720\sl360\partightenfactor0

\f0\fs32 \cf5 \cb6 \
\pard\pardeftab720\sl300\partightenfactor0

\b\fs30 \cf13 \cb1 \strokec13 \
\pard\pardeftab720\sl360\sa320\partightenfactor0
\cf5 \cb6 \strokec5 8. super in Objects\
\pard\pardeftab720\sl360\sa320\partightenfactor0

\b0\fs32 \cf5 ES6 allows to use\'a0
\f2\fs27\fsmilli13600 \cb7 super
\f0\fs32 \cb6 \'a0method in (classless) objects with prototypes. Following is a simple example:\
\pard\pardeftab720\sl380\partightenfactor0

\f2\fs27\fsmilli13600 \cf8 \cb9 \strokec8 const\cf5 \strokec5  \cf10 \strokec10 parent\cf5 \strokec5  \cf8 \strokec8 =\cf5 \strokec5  \{\
    \cf11 \strokec11 foo\cf5 \strokec5 () \{\
        \cf11 \strokec11 console\cf5 \strokec5 .\cf10 \strokec10 log\cf5 \strokec5 (\cf14 \strokec14 "Hello from the Parent"\cf5 \strokec5 );\
    \}\
\}\
\
\cf8 \strokec8 const\cf5 \strokec5  \cf10 \strokec10 child\cf5 \strokec5  \cf8 \strokec8 =\cf5 \strokec5  \{\
    \cf11 \strokec11 foo\cf5 \strokec5 () \{\
        \cf10 \strokec10 super\cf5 \strokec5 .\cf11 \strokec11 foo\cf5 \strokec5 ();\
        \cf11 \strokec11 console\cf5 \strokec5 .\cf10 \strokec10 log\cf5 \strokec5 (\cf14 \strokec14 "Hello from the Child"\cf5 \strokec5 );\
    \}\
\}\
\
\pard\pardeftab720\sl380\partightenfactor0
\cf10 \strokec10 Object\cf5 \strokec5 .\cf11 \strokec11 setPrototypeOf\cf5 \strokec5 (child, parent);\
child.\cf11 \strokec11 foo\cf5 \strokec5 (); \cf12 \strokec12 // Hello from the Parent\cf5 \strokec5 \
             \cf12 \strokec12 // Hello from the Child\cf5 \strokec5 \
\pard\pardeftab720\sl360\partightenfactor0

\f0\fs32 \cf5 \cb6 \
\pard\pardeftab720\sl300\partightenfactor0

\b\fs30 \cf13 \cb1 \strokec13 \
\pard\pardeftab720\sl360\sa320\partightenfactor0
\cf5 \cb6 \strokec5 9. Template Literal and Delimiters\
\pard\pardeftab720\sl360\sa320\partightenfactor0

\b0\fs32 \cf5 ES6 introduces an easier way to add interpolations which are evaluated automatically.\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl320\partightenfactor0
\ls2\ilvl0
\f2\fs27\fsmilli13600 \cf5 \cb7 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec5 `$\{ ... \}`
\f0\fs32 \cb6 \'a0is used for rendering the variables.\cb1 \
\ls2\ilvl0
\f2\fs27\fsmilli13600 \cb7 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec5 `
\f0\fs32 \cb6 \'a0Backtick is used as delimiter.\cb1 \
\pard\pardeftab720\sl380\partightenfactor0

\f2\fs27\fsmilli13600 \cf8 \cb9 \strokec8 let\cf5 \strokec5  user \cf8 \strokec8 =\cf5 \strokec5  \cf14 \strokec14 'Kevin'\cf5 \strokec5 ;\
\pard\pardeftab720\sl380\partightenfactor0
\cf11 \strokec11 console\cf5 \strokec5 .\cf10 \strokec10 log\cf5 \strokec5 (\cf14 \strokec14 `Hi \cf5 \strokec5 $\{user\}\cf14 \strokec14 !`\cf5 \strokec5 ); \cf12 \strokec12 // Hi Kevin!\cf5 \strokec5 \
\pard\pardeftab720\sl360\partightenfactor0

\f0\fs32 \cf5 \cb6 \
\pard\pardeftab720\sl300\partightenfactor0

\b\fs30 \cf13 \cb1 \strokec13 \
\pard\pardeftab720\sl360\sa320\partightenfactor0
\cf5 \cb6 \strokec5 10. for...of vs for...in\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl320\partightenfactor0
\ls3\ilvl0
\f2\b0\fs27\fsmilli13600 \cf5 \cb7 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec5 for...of
\f0\fs32 \cb6 \'a0iterates over iterable objects, such as array.\cb1 \
\pard\pardeftab720\sl380\partightenfactor0

\f2\fs27\fsmilli13600 \cf8 \cb9 \strokec8 const\cf5 \strokec5  \cf10 \strokec10 nicknames\cf5 \strokec5  \cf8 \strokec8 =\cf5 \strokec5  [\cf14 \strokec14 'di'\cf5 \strokec5 , \cf14 \strokec14 'boo'\cf5 \strokec5 , \cf14 \strokec14 'punkeye'\cf5 \strokec5 ];\
nicknames.\cf10 \strokec10 size\cf5 \strokec5  \cf8 \strokec8 =\cf5 \strokec5  \cf10 \strokec10 3\cf5 \strokec5 ;\
\cf8 \strokec8 for\cf5 \strokec5  (\cf8 \strokec8 let\cf5 \strokec5  nickname \cf8 \strokec8 of\cf5 \strokec5  nicknames) \{\
    \cf11 \strokec11 console\cf5 \strokec5 .\cf10 \strokec10 log\cf5 \strokec5 (nickname);\
\}\
\pard\pardeftab720\sl380\partightenfactor0
\cf12 \strokec12 // di\cf5 \strokec5 \
\cf12 \strokec12 // boo\cf5 \strokec5 \
\cf12 \strokec12 // punkeye\cf5 \strokec5 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl320\partightenfactor0
\ls4\ilvl0\cf5 \cb7 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec5 for...in
\f0\fs32 \cb6 \'a0iterates over all enumerable properties of an object.\cb1 \
\pard\pardeftab720\sl380\partightenfactor0

\f2\fs27\fsmilli13600 \cf8 \cb9 \strokec8 const\cf5 \strokec5  \cf10 \strokec10 nicknames\cf5 \strokec5  \cf8 \strokec8 =\cf5 \strokec5  [\cf14 \strokec14 'di'\cf5 \strokec5 , \cf14 \strokec14 'boo'\cf5 \strokec5 , \cf14 \strokec14 'punkeye'\cf5 \strokec5 ];\
nicknames.\cf10 \strokec10 size\cf5 \strokec5  \cf8 \strokec8 =\cf5 \strokec5  \cf10 \strokec10 3\cf5 \strokec5 ;\
\cf8 \strokec8 for\cf5 \strokec5  (\cf8 \strokec8 let\cf5 \strokec5  nickname \cf8 \strokec8 in\cf5 \strokec5  nicknames) \{\
    \cf11 \strokec11 console\cf5 \strokec5 .\cf10 \strokec10 log\cf5 \strokec5 (nickname);\
\}\
\pard\pardeftab720\sl380\partightenfactor0
\cf12 \strokec12 // 0\cf5 \strokec5 \
\cf12 \strokec12 // 1\cf5 \strokec5 \
\cf12 \strokec12 // 2\cf5 \strokec5 \
\cf12 \strokec12 // size\cf5 \strokec5 \
\pard\pardeftab720\sl360\partightenfactor0

\f0\fs32 \cf5 \cb6 \
\pard\pardeftab720\sl300\partightenfactor0

\b\fs30 \cf13 \cb1 \strokec13 \
\pard\pardeftab720\sl360\sa320\partightenfactor0
\cf5 \cb6 \strokec5 11. Map and WeakMap\
\pard\pardeftab720\sl360\sa320\partightenfactor0

\b0\fs32 \cf5 ES6 introduces new set of data structures called\'a0
\f2\fs27\fsmilli13600 \cb7 Map
\f0\fs32 \cb6 \'a0and\'a0
\f2\fs27\fsmilli13600 \cb7 WeakMap
\f0\fs32 \cb6 . Now, we actually use maps in JavaScript all the time. In fact every object can be considered as a\'a0
\f2\fs27\fsmilli13600 \cb7 Map
\f0\fs32 \cb6 .\
An object is made of keys (always strings) and values, whereas in\'a0
\f2\fs27\fsmilli13600 \cb7 Map
\f0\fs32 \cb6 , any value (both objects and primitive values) may be used as either a key or a value. Have a look at this piece of code:\
\pard\pardeftab720\sl380\partightenfactor0

\f2\fs27\fsmilli13600 \cf8 \cb9 \strokec8 const\cf5 \strokec5  \cf10 \strokec10 myMap\cf5 \strokec5  \cf8 \strokec8 =\cf5 \strokec5  \cf8 \strokec8 new\cf5 \strokec5  \cf11 \strokec11 Map\cf5 \strokec5 ();\
\
\cf8 \strokec8 const\cf5 \strokec5  \cf10 \strokec10 keyString\cf5 \strokec5  \cf8 \strokec8 =\cf5 \strokec5  \cf14 \strokec14 "a string"\cf5 \strokec5 ,\
    keyObj \cf8 \strokec8 =\cf5 \strokec5  \{\},\
    \cf11 \strokec11 keyFunc\cf5 \strokec5  \cf8 \strokec8 =\cf5 \strokec5  () \cf8 \strokec8 =>\cf5 \strokec5  \{\};\
\
\pard\pardeftab720\sl380\partightenfactor0
\cf12 \strokec12 // setting the values\cf5 \strokec5 \
myMap.\cf10 \strokec10 set\cf5 \strokec5 (keyString, \cf14 \strokec14 "value associated with 'a string'"\cf5 \strokec5 );\
myMap.\cf10 \strokec10 set\cf5 \strokec5 (keyObj, \cf14 \strokec14 "value associated with keyObj"\cf5 \strokec5 );\
myMap.\cf10 \strokec10 set\cf5 \strokec5 (keyFunc, \cf14 \strokec14 "value associated with keyFunc"\cf5 \strokec5 );\
\
myMap.\cf10 \strokec10 size\cf5 \strokec5 ; \cf12 \strokec12 // 3\cf5 \strokec5 \
\
\cf12 \strokec12 // getting the values\cf5 \strokec5 \
myMap.\cf10 \strokec10 get\cf5 \strokec5 (keyString);    \cf12 \strokec12 // "value associated with 'a string'"\cf5 \strokec5 \
myMap.\cf10 \strokec10 get\cf5 \strokec5 (keyObj);       \cf12 \strokec12 // "value associated with keyObj"\cf5 \strokec5 \
myMap.\cf10 \strokec10 get\cf5 \strokec5 (keyFunc);      \cf12 \strokec12 // "value associated with keyFunc"\cf5 \strokec5 \
\pard\pardeftab720\sl360\sa320\partightenfactor0

\f0\b\fs32 \cf5 \cb6 WeakMap
\b0 \
A\'a0
\f2\fs27\fsmilli13600 \cb7 WeakMap
\f0\fs32 \cb6 \'a0is a Map in which the keys are weakly referenced, that doesn\'92t prevent its keys from being garbage-collected. That means you don't have to worry about memory leaks.\
Another thing to note here- in\'a0
\f2\fs27\fsmilli13600 \cb7 WeakMap
\f0\fs32 \cb6 \'a0as opposed to\'a0
\f2\fs27\fsmilli13600 \cb7 Map
\f0\fs32 \cb6 \'a0
\i every key must be an object
\i0 .\
A\'a0
\f2\fs27\fsmilli13600 \cb7 WeakMap
\f0\fs32 \cb6 \'a0only has four methods\'a0
\f2\fs27\fsmilli13600 \cb7 delete(key)
\f0\fs32 \cb6 ,\'a0
\f2\fs27\fsmilli13600 \cb7 has(key)
\f0\fs32 \cb6 ,\'a0
\f2\fs27\fsmilli13600 \cb7 get(key)
\f0\fs32 \cb6 \'a0and\'a0
\f2\fs27\fsmilli13600 \cb7 set(key, value)
\f0\fs32 \cb6 .\
\pard\pardeftab720\sl380\partightenfactor0

\f2\fs27\fsmilli13600 \cf8 \cb9 \strokec8 const\cf5 \strokec5  \cf10 \strokec10 w\cf5 \strokec5  \cf8 \strokec8 =\cf5 \strokec5  \cf8 \strokec8 new\cf5 \strokec5  \cf11 \strokec11 WeakMap\cf5 \strokec5 ();\
w.\cf10 \strokec10 set\cf5 \strokec5 (\cf14 \strokec14 'a'\cf5 \strokec5 , \cf14 \strokec14 'b'\cf5 \strokec5 );\
\pard\pardeftab720\sl380\partightenfactor0
\cf12 \strokec12 // Uncaught TypeError: Invalid value used as weak map key\cf5 \strokec5 \
\
\pard\pardeftab720\sl380\partightenfactor0
\cf8 \strokec8 const\cf5 \strokec5  \cf10 \strokec10 o1\cf5 \strokec5  \cf8 \strokec8 =\cf5 \strokec5  \{\},\
    \cf11 \strokec11 o2\cf5 \strokec5  \cf8 \strokec8 =\cf5 \strokec5  () \cf8 \strokec8 =>\cf5 \strokec5  \{\},\
    o3 \cf8 \strokec8 =\cf5 \strokec5  \cf10 \strokec10 window\cf5 \strokec5 ;\
\
w.\cf10 \strokec10 set\cf5 \strokec5 (o1, \cf10 \strokec10 37\cf5 \strokec5 );\
w.\cf10 \strokec10 set\cf5 \strokec5 (o2, \cf14 \strokec14 "azerty"\cf5 \strokec5 );\
w.\cf10 \strokec10 set\cf5 \strokec5 (o3, \cf10 \strokec10 undefined\cf5 \strokec5 );\
\
w.\cf10 \strokec10 get\cf5 \strokec5 (o3); \cf12 \strokec12 // undefined, because that is the set value\cf5 \strokec5 \
\
w.\cf10 \strokec10 has\cf5 \strokec5 (o1); \cf12 \strokec12 // true\cf5 \strokec5 \
w.\cf10 \strokec10 delete\cf5 \strokec5 (o1);\
w.\cf10 \strokec10 has\cf5 \strokec5 (o1); \cf12 \strokec12 // false\cf5 \strokec5 \
\pard\pardeftab720\sl360\partightenfactor0

\f0\fs32 \cf5 \cb6 \
\pard\pardeftab720\sl300\partightenfactor0

\b\fs30 \cf13 \cb1 \strokec13 \
\pard\pardeftab720\sl360\sa320\partightenfactor0
\cf5 \cb6 \strokec5 12. Set and WeakSet\
\pard\pardeftab720\sl360\sa320\partightenfactor0

\i\b0\fs32 \cf5 Set
\i0 \'a0objects are collections of unique values. Duplicate values are ignored, as the collection must have all unique values. The values can be primitive types or object references.\
\pard\pardeftab720\sl380\partightenfactor0

\f2\fs27\fsmilli13600 \cf8 \cb9 \strokec8 const\cf5 \strokec5  \cf10 \strokec10 mySet\cf5 \strokec5  \cf8 \strokec8 =\cf5 \strokec5  \cf8 \strokec8 new\cf5 \strokec5  \cf11 \strokec11 Set\cf5 \strokec5 ([\cf10 \strokec10 1\cf5 \strokec5 , \cf10 \strokec10 1\cf5 \strokec5 , \cf10 \strokec10 2\cf5 \strokec5 , \cf10 \strokec10 2\cf5 \strokec5 , \cf10 \strokec10 3\cf5 \strokec5 , \cf10 \strokec10 3\cf5 \strokec5 ]);\
mySet.\cf10 \strokec10 size\cf5 \strokec5 ; \cf12 \strokec12 // 3\cf5 \strokec5 \
mySet.\cf10 \strokec10 has\cf5 \strokec5 (\cf10 \strokec10 1\cf5 \strokec5 ); \cf12 \strokec12 // true\cf5 \strokec5 \
mySet.\cf10 \strokec10 add\cf5 \strokec5 (\cf14 \strokec14 'strings'\cf5 \strokec5 );\
mySet.\cf10 \strokec10 add\cf5 \strokec5 (\{ a\cf8 \strokec8 :\cf5 \strokec5  \cf10 \strokec10 1\cf5 \strokec5 , b\cf8 \strokec8 :\cf10 \strokec10 2\cf5 \strokec5  \});\
\pard\pardeftab720\sl360\sa320\partightenfactor0

\f0\fs32 \cf5 \cb6 You can iterate over a set by insertion order using either the\'a0
\f2\fs27\fsmilli13600 \cb7 forEach
\f0\fs32 \cb6 \'a0method or the\'a0
\f2\fs27\fsmilli13600 \cb7 for...of
\f0\fs32 \cb6 \'a0loop.\
\pard\pardeftab720\sl380\partightenfactor0

\f2\fs27\fsmilli13600 \cf5 \cb9 mySet.\cf10 \strokec10 forEach\cf5 \strokec5 ((item) \cf8 \strokec8 =>\cf5 \strokec5  \{\
    \cf11 \strokec11 console\cf5 \strokec5 .\cf10 \strokec10 log\cf5 \strokec5 (item);\
    \cf12 \strokec12 // 1\cf5 \strokec5 \
    \cf12 \strokec12 // 2\cf5 \strokec5 \
    \cf12 \strokec12 // 3\cf5 \strokec5 \
    \cf12 \strokec12 // 'strings'\cf5 \strokec5 \
    \cf12 \strokec12 // Object \{ a: 1, b: 2 \}\cf5 \strokec5 \
\});\
\
\pard\pardeftab720\sl380\partightenfactor0
\cf8 \strokec8 for\cf5 \strokec5  (\cf8 \strokec8 let\cf5 \strokec5  value \cf8 \strokec8 of\cf5 \strokec5  mySet) \{\
    \cf11 \strokec11 console\cf5 \strokec5 .\cf10 \strokec10 log\cf5 \strokec5 (value);\
    \cf12 \strokec12 // 1\cf5 \strokec5 \
    \cf12 \strokec12 // 2\cf5 \strokec5 \
    \cf12 \strokec12 // 3\cf5 \strokec5 \
    \cf12 \strokec12 // 'strings'\cf5 \strokec5 \
    \cf12 \strokec12 // Object \{ a: 1, b: 2 \}\cf5 \strokec5 \
\}\
\pard\pardeftab720\sl360\sa320\partightenfactor0

\f0\fs32 \cf5 \cb6 Sets also have the\'a0
\f2\fs27\fsmilli13600 \cb7 delete()
\f0\fs32 \cb6 \'a0and\'a0
\f2\fs27\fsmilli13600 \cb7 clear()
\f0\fs32 \cb6 \'a0methods.\
\pard\pardeftab720\sl360\sa320\partightenfactor0

\b \cf5 WeakSet
\b0 \
Similar to\'a0
\f2\fs27\fsmilli13600 \cb7 WeakMap
\f0\fs32 \cb6 , the\'a0
\f2\fs27\fsmilli13600 \cb7 WeakSet
\f0\fs32 \cb6 \'a0object lets you store weakly held\'a0
\i objects
\i0 \'a0in a collection. An object in the\'a0
\f2\fs27\fsmilli13600 \cb7 WeakSet
\f0\fs32 \cb6 \'a0occurs only once; it is unique in the WeakSet's collection.\
\pard\pardeftab720\sl380\partightenfactor0

\f2\fs27\fsmilli13600 \cf8 \cb9 \strokec8 const\cf5 \strokec5  \cf10 \strokec10 ws\cf5 \strokec5  \cf8 \strokec8 =\cf5 \strokec5  \cf8 \strokec8 new\cf5 \strokec5  \cf11 \strokec11 WeakSet\cf5 \strokec5 ();\
\cf8 \strokec8 const\cf5 \strokec5  \cf10 \strokec10 obj\cf5 \strokec5  \cf8 \strokec8 =\cf5 \strokec5  \{\};\
\cf8 \strokec8 const\cf5 \strokec5  \cf10 \strokec10 foo\cf5 \strokec5  \cf8 \strokec8 =\cf5 \strokec5  \{\};\
\
ws.\cf10 \strokec10 add\cf5 \strokec5 (\cf10 \strokec10 window\cf5 \strokec5 );\
ws.\cf10 \strokec10 add\cf5 \strokec5 (obj);\
\
ws.\cf10 \strokec10 has\cf5 \strokec5 (\cf10 \strokec10 window\cf5 \strokec5 ); \cf12 \strokec12 // true\cf5 \strokec5 \
ws.\cf10 \strokec10 has\cf5 \strokec5 (foo);    \cf12 \strokec12 // false, foo has not been added to the set\cf5 \strokec5 \
\
ws.\cf10 \strokec10 delete\cf5 \strokec5 (\cf10 \strokec10 window\cf5 \strokec5 ); \cf12 \strokec12 // removes window from the set\cf5 \strokec5 \
ws.\cf10 \strokec10 has\cf5 \strokec5 (\cf10 \strokec10 window\cf5 \strokec5 );    \cf12 \strokec12 // false, window has been removed\cf5 \strokec5 \
\pard\pardeftab720\sl360\partightenfactor0

\f0\fs32 \cf5 \cb6 \
\pard\pardeftab720\sl300\partightenfactor0

\b\fs30 \cf13 \cb1 \strokec13 \
\pard\pardeftab720\sl360\sa320\partightenfactor0
\cf5 \cb6 \strokec5 13. Classes in ES6\
\pard\pardeftab720\sl360\sa320\partightenfactor0

\b0\fs32 \cf5 ES6 introduces new class syntax. One thing to note here is that ES6 class is not a new object-oriented inheritance model. They just serve as a syntactical sugar over JavaScript's existing prototype-based inheritance.\
One way to look at a class in ES6 is just a new syntax to work with prototypes and contructor functions that we'd use in ES5.\
Functions defined using the\'a0
\f2\fs27\fsmilli13600 \cb7 static
\f0\fs32 \cb6 \'a0keyword implement static/class functions on the class.\
\pard\pardeftab720\sl380\partightenfactor0

\f2\fs27\fsmilli13600 \cf8 \cb9 \strokec8 class\cf5 \strokec5  \cf11 \strokec11 Task\cf5 \strokec5  \{\
    \cf11 \strokec11 constructor\cf5 \strokec5 () \{\
        \cf11 \strokec11 console\cf5 \strokec5 .\cf10 \strokec10 log\cf5 \strokec5 (\cf14 \strokec14 "task instantiated!"\cf5 \strokec5 );\
    \}\
\
    \cf11 \strokec11 showId\cf5 \strokec5 () \{\
        \cf11 \strokec11 console\cf5 \strokec5 .\cf10 \strokec10 log\cf5 \strokec5 (\cf10 \strokec10 23\cf5 \strokec5 );\
    \}\
\
    \cf8 \strokec8 static\cf5 \strokec5  \cf11 \strokec11 loadAll\cf5 \strokec5 () \{\
        \cf11 \strokec11 console\cf5 \strokec5 .\cf10 \strokec10 log\cf5 \strokec5 (\cf14 \strokec14 "Loading all tasks.."\cf5 \strokec5 );\
    \}\
\}\
\
\pard\pardeftab720\sl380\partightenfactor0
\cf11 \strokec11 console\cf5 \strokec5 .\cf10 \strokec10 log\cf5 \strokec5 (\cf8 \strokec8 typeof\cf5 \strokec5  Task); \cf12 \strokec12 // function\cf5 \strokec5 \
\pard\pardeftab720\sl380\partightenfactor0
\cf8 \strokec8 const\cf5 \strokec5  \cf10 \strokec10 task\cf5 \strokec5  \cf8 \strokec8 =\cf5 \strokec5  \cf8 \strokec8 new\cf5 \strokec5  \cf11 \strokec11 Task\cf5 \strokec5 (); \cf12 \strokec12 // "task instantiated!"\cf5 \strokec5 \
task.\cf11 \strokec11 showId\cf5 \strokec5 (); \cf12 \strokec12 // 23\cf5 \strokec5 \
Task.\cf11 \strokec11 loadAll\cf5 \strokec5 (); \cf12 \strokec12 // "Loading all tasks.."\cf5 \strokec5 \
\pard\pardeftab720\sl360\sa320\partightenfactor0

\f0\b\fs32 \cf5 \cb6 extends and super in classes
\b0 \
Consider the following code:\
\pard\pardeftab720\sl380\partightenfactor0

\f2\fs27\fsmilli13600 \cf8 \cb9 \strokec8 class\cf5 \strokec5  \cf11 \strokec11 Car\cf5 \strokec5  \{\
    \cf11 \strokec11 constructor\cf5 \strokec5 () \{\
        \cf11 \strokec11 console\cf5 \strokec5 .\cf10 \strokec10 log\cf5 \strokec5 (\cf14 \strokec14 "Creating a new car"\cf5 \strokec5 );\
    \}\
\}\
\
\cf8 \strokec8 class\cf5 \strokec5  \cf11 \strokec11 Porsche\cf5 \strokec5  \cf8 \strokec8 extends\cf5 \strokec5  \cf11 \strokec11 Car\cf5 \strokec5  \{\
    \cf11 \strokec11 constructor\cf5 \strokec5 () \{\
        \cf10 \strokec10 super\cf5 \strokec5 ();\
        \cf11 \strokec11 console\cf5 \strokec5 .\cf10 \strokec10 log\cf5 \strokec5 (\cf14 \strokec14 "Creating Porsche"\cf5 \strokec5 );\
    \}\
\}\
\
\cf8 \strokec8 let\cf5 \strokec5  c \cf8 \strokec8 =\cf5 \strokec5  \cf8 \strokec8 new\cf5 \strokec5  \cf11 \strokec11 Porsche\cf5 \strokec5 ();\
\pard\pardeftab720\sl380\partightenfactor0
\cf12 \strokec12 // Creating a new car\cf5 \strokec5 \
\cf12 \strokec12 // Creating Porsche\cf5 \strokec5 \
\pard\pardeftab720\sl320\sa320\partightenfactor0
\cf5 \cb7 extends
\f0\fs32 \cb6 \'a0allow child class to inherit from parent class in ES6. It is important to note that the derived constructor must call\'a0
\f2\fs27\fsmilli13600 \cb7 super()
\f0\fs32 \cb6 .\
\pard\pardeftab720\sl360\sa320\partightenfactor0
\cf5 Also, you can call parent class's method in child class's methods using\'a0
\f2\fs27\fsmilli13600 \cb7 super.parentMethodName()
\f0\fs32 \cb6 \
\pard\pardeftab720\sl360\sa320\partightenfactor0
{\field{\*\fldinst{HYPERLINK "https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes"}}{\fldrslt \cf13 \strokec13 Read more about classes here}}\
A few things to keep in mind:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl360\partightenfactor0
\ls5\ilvl0\cf5 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec5 Class declarations are not hoisted. You first need to declare your class and then access it, otherwise ReferenceError will be thrown.\cb1 \
\ls5\ilvl0\cb6 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec5 There is no need to use\'a0
\f2\fs27\fsmilli13600 \cb7 function
\f0\fs32 \cb6 \'a0keyword when defining functions inside a class definition.\cb1 \
\pard\pardeftab720\sl360\partightenfactor0
\cf5 \cb6 \
\pard\pardeftab720\sl300\partightenfactor0

\b\fs30 \cf13 \cb1 \strokec13 \
\pard\pardeftab720\sl360\sa320\partightenfactor0
\cf5 \cb6 \strokec5 14. Symbol\
\pard\pardeftab720\sl360\sa320\partightenfactor0

\b0\fs32 \cf5 A\'a0
\f2\fs27\fsmilli13600 \cb7 Symbol
\f0\fs32 \cb6 \'a0is a unique and immutable data type introduced in ES6. The purpose of a symbol is to generate a unique identifier but you can never get any access to that identifier.\
Here\'92s how you create a symbol:\
\pard\pardeftab720\sl380\partightenfactor0

\f2\fs27\fsmilli13600 \cf8 \cb9 \strokec8 const\cf5 \strokec5  \cf10 \strokec10 sym\cf5 \strokec5  \cf8 \strokec8 =\cf5 \strokec5  \cf10 \strokec10 Symbol\cf5 \strokec5 (\cf14 \strokec14 "some optional description"\cf5 \strokec5 );\
\pard\pardeftab720\sl380\partightenfactor0
\cf11 \strokec11 console\cf5 \strokec5 .\cf10 \strokec10 log\cf5 \strokec5 (\cf8 \strokec8 typeof\cf5 \strokec5  sym); \cf12 \strokec12 // symbol\cf5 \strokec5 \
\pard\pardeftab720\sl360\sa320\partightenfactor0

\f0\fs32 \cf5 \cb6 Note that you cannot use\'a0
\f2\fs27\fsmilli13600 \cb7 new
\f0\fs32 \cb6 \'a0with\'a0
\f2\fs27\fsmilli13600 \cb7 Symbol(\'85)
\f0\fs32 \cb6 .\
If a symbol is used as a property/key of an object, it\'92s stored in a special way that the property will not show up in a normal enumeration of the object\'92s properties.\
\pard\pardeftab720\sl380\partightenfactor0

\f2\fs27\fsmilli13600 \cf8 \cb9 \strokec8 const\cf5 \strokec5  \cf10 \strokec10 o\cf5 \strokec5  \cf8 \strokec8 =\cf5 \strokec5  \{\
    val\cf8 \strokec8 :\cf5 \strokec5  \cf10 \strokec10 10\cf5 \strokec5 ,\
    [\cf10 \strokec10 Symbol\cf5 \strokec5 (\cf14 \strokec14 "random"\cf5 \strokec5 )]\cf8 \strokec8 :\cf5 \strokec5  \cf14 \strokec14 "I'm a symbol"\cf5 \strokec5 ,\
\};\
\
\pard\pardeftab720\sl380\partightenfactor0
\cf11 \strokec11 console\cf5 \strokec5 .\cf10 \strokec10 log\cf5 \strokec5 (\cf10 \strokec10 Object\cf5 \strokec5 .\cf11 \strokec11 getOwnPropertyNames\cf5 \strokec5 (o)); \cf12 \strokec12 // val\cf5 \strokec5 \
\pard\pardeftab720\sl360\sa320\partightenfactor0

\f0\fs32 \cf5 \cb6 To retrieve an object\'92s symbol properties, use\'a0
\f2\fs27\fsmilli13600 \cb7 Object.getOwnPropertySymbols(o)
\f0\fs32 \cb6 \
\pard\pardeftab720\sl360\partightenfactor0
\cf5 \
\pard\pardeftab720\sl300\partightenfactor0

\b\fs30 \cf13 \cb1 \strokec13 \
\pard\pardeftab720\sl360\sa320\partightenfactor0
\cf5 \cb6 \strokec5 15. Iterators\
\pard\pardeftab720\sl360\sa320\partightenfactor0

\b0\fs32 \cf5 An iterator accesses the items from a collection one at a time, while keeping track of its current position within that sequence. It provides a\'a0
\f2\fs27\fsmilli13600 \cb7 next()
\f0\fs32 \cb6 \'a0method which returns the next item in the sequence. This method returns an object with two properties: done and value.\
ES6 has\'a0
\f2\fs27\fsmilli13600 \cb7 Symbol.iterator
\f0\fs32 \cb6 \'a0which specifies the default iterator for an object. Whenever an object needs to be iterated (such as at the beginning of a for..of loop), its\'a0
\i @@iterator
\i0 \'a0method is called with no arguments, and the returned iterator is used to obtain the values to be iterated.\
Let\'92s look at an array, which is an iterable, and the iterator it can produce to consume its values:\
\pard\pardeftab720\sl380\partightenfactor0

\f2\fs27\fsmilli13600 \cf8 \cb9 \strokec8 const\cf5 \strokec5  \cf10 \strokec10 arr\cf5 \strokec5  \cf8 \strokec8 =\cf5 \strokec5  [\cf10 \strokec10 11\cf5 \strokec5 ,\cf10 \strokec10 12\cf5 \strokec5 ,\cf10 \strokec10 13\cf5 \strokec5 ];\
\cf8 \strokec8 const\cf5 \strokec5  \cf10 \strokec10 itr\cf5 \strokec5  \cf8 \strokec8 =\cf5 \strokec5  arr[\cf10 \strokec10 Symbol\cf5 \strokec5 .iterator]();\
\
itr.\cf10 \strokec10 next\cf5 \strokec5 (); \cf12 \strokec12 // \{ value: 11, done: false \}\cf5 \strokec5 \
itr.\cf10 \strokec10 next\cf5 \strokec5 (); \cf12 \strokec12 // \{ value: 12, done: false \}\cf5 \strokec5 \
itr.\cf10 \strokec10 next\cf5 \strokec5 (); \cf12 \strokec12 // \{ value: 13, done: false \}\cf5 \strokec5 \
\
itr.\cf10 \strokec10 next\cf5 \strokec5 (); \cf12 \strokec12 // \{ value: undefined, done: true \}\cf5 \strokec5 \
\pard\pardeftab720\sl360\sa320\partightenfactor0

\f0\fs32 \cf5 \cb6 Note that you can write custom iterators by defining\'a0
\f2\fs27\fsmilli13600 \cb7 obj[Symbol.iterator]()
\f0\fs32 \cb6 \'a0with the object definition.\
\pard\pardeftab720\sl360\partightenfactor0
\cf5 \
\pard\pardeftab720\sl300\partightenfactor0

\b\fs30 \cf13 \cb1 \strokec13 \
\pard\pardeftab720\sl360\sa320\partightenfactor0
\cf5 \cb6 \strokec5 16. Generators\
\pard\pardeftab720\sl360\sa320\partightenfactor0

\b0\fs32 \cf5 Generator functions are a new feature in ES6 that allow a function to generate many values over time by returning an object which can be iterated over to pull values from the function one value at a time.\
A generator function returns an\'a0
\b iterable object
\b0 \'a0when it's called. It is written using the new\'a0
\f2\fs27\fsmilli13600 \cb7 *
\f0\fs32 \cb6 \'a0syntax as well as the new\'a0
\f2\fs27\fsmilli13600 \cb7 yield
\f0\fs32 \cb6 \'a0keyword introduced in ES6.\
\pard\pardeftab720\sl380\partightenfactor0

\f2\fs27\fsmilli13600 \cf8 \cb9 \strokec8 function\cf5 \strokec5  \cf8 \strokec8 *\cf11 \strokec11 infiniteNumbers\cf5 \strokec5 () \{\
    \cf8 \strokec8 let\cf5 \strokec5  n \cf8 \strokec8 =\cf5 \strokec5  \cf10 \strokec10 1\cf5 \strokec5 ;\
    \cf8 \strokec8 while\cf5 \strokec5  (\cf10 \strokec10 true\cf5 \strokec5 ) \{\
        \cf8 \strokec8 yield\cf5 \strokec5  n\cf8 \strokec8 ++\cf5 \strokec5 ;\
    \}\
\}\
\
\cf8 \strokec8 const\cf5 \strokec5  \cf10 \strokec10 numbers\cf5 \strokec5  \cf8 \strokec8 =\cf5 \strokec5  \cf11 \strokec11 infiniteNumbers\cf5 \strokec5 (); \cf12 \strokec12 // returns an iterable object\cf5 \strokec5 \
\
numbers.\cf10 \strokec10 next\cf5 \strokec5 (); \cf12 \strokec12 // \{ value: 1, done: false \}\cf5 \strokec5 \
numbers.\cf10 \strokec10 next\cf5 \strokec5 (); \cf12 \strokec12 // \{ value: 2, done: false \}\cf5 \strokec5 \
numbers.\cf10 \strokec10 next\cf5 \strokec5 (); \cf12 \strokec12 // \{ value: 3, done: false \}\cf5 \strokec5 \
\pard\pardeftab720\sl360\sa320\partightenfactor0

\f0\fs32 \cf5 \cb6 Each time\'a0
\i yield
\i0 \'a0is called, the yielded value becomes the next value in the sequence.\
Also, note that generators compute their yielded values on demand, which allows them to efficiently represent sequences that are expensive to compute, or even infinite sequences.\
\pard\pardeftab720\sl360\partightenfactor0
\cf5 \
\pard\pardeftab720\sl300\partightenfactor0

\b\fs30 \cf13 \cb1 \strokec13 \
\pard\pardeftab720\sl360\sa320\partightenfactor0
\cf5 \cb6 \strokec5 17. Promises\
\pard\pardeftab720\sl360\sa320\partightenfactor0

\b0\fs32 \cf5 ES6 has native support for promises. A\'a0
\i promise
\i0 \'a0is an object that is waiting for an asynchronous operation to complete, and when that operation completes, the promise is either fulfilled(resolved) or rejected.\
The standard way to create a Promise is by using the\'a0
\f2\fs27\fsmilli13600 \cb7 new Promise()
\f0\fs32 \cb6 \'a0constructor which accepts a handler that is given two functions as parameters. The first handler (typically named\'a0
\f2\fs27\fsmilli13600 \cb7 resolve
\f0\fs32 \cb6 ) is a function to call with the future value when it's ready; and the second handler (typically named\'a0
\f2\fs27\fsmilli13600 \cb7 reject
\f0\fs32 \cb6 ) is a function to call to reject the Promise if it can't resolve the future value.\
\pard\pardeftab720\sl380\partightenfactor0

\f2\fs27\fsmilli13600 \cf8 \cb9 \strokec8 const\cf5 \strokec5  \cf10 \strokec10 p\cf5 \strokec5  \cf8 \strokec8 =\cf5 \strokec5  \cf8 \strokec8 new\cf5 \strokec5  \cf11 \strokec11 Promise\cf5 \strokec5 ((resolve, reject) \cf8 \strokec8 =>\cf5 \strokec5  \{\
    \cf8 \strokec8 if\cf5 \strokec5  (\cf12 \strokec12 /* condition */\cf5 \strokec5 ) \{\
        \cf11 \strokec11 resolve\cf5 \strokec5 (\cf12 \strokec12 /* value */\cf5 \strokec5 );  \cf12 \strokec12 // fulfilled successfully\cf5 \strokec5 \
    \} \cf8 \strokec8 else\cf5 \strokec5  \{\
        \cf11 \strokec11 reject\cf5 \strokec5 (\cf12 \strokec12 /* reason */\cf5 \strokec5 );  \cf12 \strokec12 // error, rejected\cf5 \strokec5 \
    \}\
\});\
\pard\pardeftab720\sl360\sa320\partightenfactor0

\f0\fs32 \cf5 \cb6 Every Promise has a method named\'a0
\f2\fs27\fsmilli13600 \cb7 then
\f0\fs32 \cb6 \'a0which takes a pair of callbacks. The first callback is called if the promise is resolved, while the second is called if the promise is rejected.\
\pard\pardeftab720\sl380\partightenfactor0

\f2\fs27\fsmilli13600 \cf5 \cb9 p.\cf10 \strokec10 then\cf5 \strokec5 ((val) \cf8 \strokec8 =>\cf5 \strokec5  \cf11 \strokec11 console\cf5 \strokec5 .\cf10 \strokec10 log\cf5 \strokec5 (\cf14 \strokec14 "Promise Resolved"\cf5 \strokec5 , val),\
       (err) \cf8 \strokec8 =>\cf5 \strokec5  \cf11 \strokec11 console\cf5 \strokec5 .\cf10 \strokec10 log\cf5 \strokec5 (\cf14 \strokec14 "Promise Rejected"\cf5 \strokec5 , err));\
\pard\pardeftab720\sl360\sa320\partightenfactor0

\f0\fs32 \cf5 \cb6 Returning a value from\'a0
\f2\fs27\fsmilli13600 \cb7 then
\f0\fs32 \cb6 \'a0callbacks will pass the value to the next\'a0
\f2\fs27\fsmilli13600 \cb7 then
\f0\fs32 \cb6 \'a0callback.\
\pard\pardeftab720\sl380\partightenfactor0

\f2\fs27\fsmilli13600 \cf8 \cb9 \strokec8 const\cf5 \strokec5  \cf10 \strokec10 hello\cf5 \strokec5  \cf8 \strokec8 =\cf5 \strokec5  \cf8 \strokec8 new\cf5 \strokec5  \cf11 \strokec11 Promise\cf5 \strokec5 ((resolve, reject) \cf8 \strokec8 =>\cf5 \strokec5  \{ \cf11 \strokec11 resolve\cf5 \strokec5 (\cf14 \strokec14 "Hello"\cf5 \strokec5 ) \});\
\
hello.\cf10 \strokec10 then\cf5 \strokec5 ((str) \cf8 \strokec8 =>\cf5 \strokec5  \cf14 \strokec14 `\cf5 \strokec5 $\{str\}\cf14 \strokec14  World`\cf5 \strokec5 )\
     .\cf10 \strokec10 then\cf5 \strokec5 ((str) \cf8 \strokec8 =>\cf5 \strokec5  \cf14 \strokec14 `\cf5 \strokec5 $\{str\}\cf14 \strokec14 !`\cf5 \strokec5 )\
     .\cf10 \strokec10 then\cf5 \strokec5 ((str) \cf8 \strokec8 =>\cf5 \strokec5  \cf11 \strokec11 console\cf5 \strokec5 .\cf10 \strokec10 log\cf5 \strokec5 (str)) \cf12 \strokec12 // Hello World!\cf5 \strokec5 \
\pard\pardeftab720\sl360\sa320\partightenfactor0

\f0\fs32 \cf5 \cb6 When returning a promise, the resolved value of the promise will get passed to the next callback to effectively chain them together. This is a simple technique to avoid "callback hell".\
\pard\pardeftab720\sl380\partightenfactor0

\f2\fs27\fsmilli13600 \cf8 \cb9 \strokec8 const\cf5 \strokec5  \cf10 \strokec10 p\cf5 \strokec5  \cf8 \strokec8 =\cf5 \strokec5  \cf8 \strokec8 new\cf5 \strokec5  \cf11 \strokec11 Promise\cf5 \strokec5 ((resolve, reject) \cf8 \strokec8 =>\cf5 \strokec5  \{ \cf11 \strokec11 resolve\cf5 \strokec5 (\cf10 \strokec10 1\cf5 \strokec5 ) \});\
\
\cf8 \strokec8 const\cf5 \strokec5  \cf10 \strokec10 eventuallyAdd1\cf5 \strokec5  \cf8 \strokec8 =\cf5 \strokec5  (val) \cf8 \strokec8 =>\cf5 \strokec5  \cf8 \strokec8 new\cf5 \strokec5  \cf11 \strokec11 Promise\cf5 \strokec5 ((resolve, reject) \cf8 \strokec8 =>\cf5 \strokec5  \{ \cf11 \strokec11 resolve\cf5 \strokec5 (val \cf8 \strokec8 +\cf5 \strokec5  \cf10 \strokec10 1\cf5 \strokec5 ) \});\
\
p.\cf10 \strokec10 then\cf5 \strokec5 (eventuallyAdd1)\
 .\cf10 \strokec10 then\cf5 \strokec5 (eventuallyAdd1)\
 .\cf10 \strokec10 then\cf5 \strokec5 ((val) \cf8 \strokec8 =>\cf5 \strokec5  \cf11 \strokec11 console\cf5 \strokec5 .\cf10 \strokec10 log\cf5 \strokec5 (val)); \cf12 \strokec12 // 3\cf5 \strokec5 \
}